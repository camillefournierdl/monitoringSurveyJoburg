---
title: "policyPreferences"
output: html_document
---

```{r setup}

library(tidyverse)
library(RColorBrewer)
library(scales)

## For replicability: session information 
session_info <- print(sessionInfo())

```



```{r load the data}
"%ni%" = Negate("%in%")

set.seed(123)

dataJoburg <- read.csv("data/data_joh_person_anon.csv")
```


```{r data cleaning}
# filter out straightlining for the policies "On days where air pollution is high..."

# Identify columns starting with "AM_GovAction_S"
gov_cols <- grep("^AM_GovAction_S", names(dataJoburg), value = TRUE)

# Calculate the row-wise standard deviation for these columns and filter out straightliners
dataJoburgFilter <- dataJoburg %>%
  mutate(gov_sd = apply(select(., all_of(gov_cols)), 1, sd, na.rm = TRUE)) %>%
  filter(gov_sd != 0) %>%
  select(-gov_sd)

dataJoburg <- dataJoburgFilter

```



```{r figure policy pref}

# --- Step 1: Recode and factor all three policy variables ---
recode_policy <- function(x) {
  factor(recode(x,
    `1` = "Disagree",
    `2` = "dot_1 ", # Ensure consistent spacing for internal names if they are part of the level string
    `3` = "Neither",
    `4` = "dot_2  ", # Consistent spacing for internal names (note two spaces at end to differentiate from dot_1 )
    `5` = "Agree"
  ),
  # Ensure these levels match the strings used in recode exactly, including spaces
  levels = c("Disagree", "dot_1 ", "Neither", "dot_2  ", "Agree"),
  ordered = TRUE
  )
}

dataJoburg <- dataJoburg %>%
  mutate(
    AM_GovAction_S1_1F = recode_policy(AM_GovAction_S1_1),
    AM_GovAction_S2_1F = recode_policy(AM_GovAction_S2_1),
    AM_GovAction_S3_1F = recode_policy(AM_GovAction_S3_1),
    AM_GovAction_S4_1F = recode_policy(AM_GovAction_S4_1),
    AM_GovAction_S5_1F = recode_policy(AM_GovAction_S5_1),
    AM_GovAction_S6_1F = recode_policy(AM_GovAction_S6_1),
    AM_GovAction_S7_1F = recode_policy(AM_GovAction_S7_1)
  )

# --- Step 2: Pivot the data to long format and summarize ---
# Select only the newly created _F columns for pivoting
summary_data <- dataJoburg %>%
  select(starts_with("AM_GovAction_S")) %>% # Selects all columns starting with "AM_GovAction_S" and ending with F
                                          # Make sure this accurately captures your variables
  pivot_longer(
    cols = ends_with("F"), # Selects all columns ending with "F" for flexibility
    names_to = "Question",
    values_to = "Response_Category",
    values_drop_na = TRUE
  ) %>%
  group_by(Question, Response_Category) %>%
  summarise(obs_count = n(), .groups = "drop_last") %>% # Renamed 'count' to 'obs_count' to avoid conflict
  mutate(share = obs_count / sum(obs_count)) %>%
  ungroup() %>%
  group_by(Question) %>% # Regroup by Question to apply cumulative sum per group
  arrange(fct_rev(Response_Category)) %>% # IMPORTANT: Arrange by the factor order of Response_Category
  mutate(
    y_max = cumsum(share),
    y_mid = y_max - (share / 2),
    label_text = as.character(round(share * 100))
  ) %>%
  ungroup()

# --- Step 3: Define the order and labels for the plot and legend ---
# Labels for the LEGEND
legend_labels_full <- c(
  "Disagree",
  " ● ", # Consistent legend label for dot_1
  "Neither",
  "  ●  ", # Consistent legend label for dot_2
  "Agree"
)

# This should be the natural order of your factor levels from recode_policy
fill_levels_defined_order <- levels(dataJoburg$AM_GovAction_S1_1F)

# Define the custom labels for the Y-axis (Question labels after coord_flip)
# IMPORTANT: Adjust 'levels' to the exact names of your `_F` variables
# and 'labels' to their desired display names.
summary_data$Question_Plot_Label <- factor(summary_data$Question,
                                           levels = c("AM_GovAction_S1_1F", "AM_GovAction_S2_1F", "AM_GovAction_S3_1F", "AM_GovAction_S4_1F", "AM_GovAction_S5_1F", "AM_GovAction_S6_1F", "AM_GovAction_S7_1F"), # Customize this order
                                           labels = c("Send warning to phones", "Reduce traffic", "Ban old vehicles", "Close schools and unis", "Stop construction work", "Prohibit waste burning", "Make public transport free"), # Customize these labels
                                           ordered = TRUE) %>%
                                    fct_rev() # Reverse the order for plotting with coord_flip

# --- Plotting the Horizontal Stacked Bar Plot with custom text positions ---
p_stacked_fixed <- ggplot(summary_data, aes(x = Question_Plot_Label, y = share,
                                             fill = Response_Category)) + 
  geom_col(width = 0.6) +
  geom_text(
    aes(y = y_mid, label = label_text, color = "black"),
    size = 3,
    na.rm = FALSE
  ) +
  coord_flip() + # Rotate to horizontal
  scale_y_continuous(
    labels = percent_format(accuracy = 1),
    expand = expansion(mult = c(0, 0.02))
  ) +
  scale_fill_manual(
    values = brewer.pal(5, "BuPu"), # Consider if BuPu is ideal for "Disagree/Agree"
    limits = rev(fill_levels_defined_order), # Reverse the order for the fill scale limits
    labels = rev(legend_labels_full) # Also reverse the labels for the legend to match the plot
  ) +
  scale_color_identity() +
  labs(
    x = "",
    y = "Percentage",
    fill = "Response",
    title = "On days when air pollution is bad, should the government..." # Generalize title
  ) +
  theme_minimal() +
  theme(
    legend.position = "top",
    legend.title = element_blank(),
    axis.text.y = element_text(size = 10, face = "bold"),
    axis.text.x = element_text(size = 8),
    axis.title.x = element_text(size = 9),
    plot.title = element_text(size = 12, face = "bold")
  )

print(p_stacked_fixed)

# Save the plot
ggsave(plot = p_stacked_fixed, filename = paste("plots/policy_pref_stacked.png", sep = ""),
       dpi=600, width = 18, height = 10, units='cm')


```

